{% import '@SgDatatables/Helper/macros.html.twig' as macros %}

{##
 # This file is part of the SgDatatablesBundle package.
 #
 # (c) stwe <https://github.com/stwe/DatatablesBundle>
 #
 # For the full copyright and license information, please view the LICENSE
 # file that was distributed with this source code.
 #}
"serverSide": true,
"ajax": {
    "url": "{{ view_ajax.url|raw }}",
    "type": "{{ view_ajax.type }}",
    {% if view_ajax.pipeline > 0 %}
        "pages": {{ view_ajax.pipeline }},
    {% endif %}
    {% if (view_ajax.dataSrc) %}
        "dataSrc": {{ macros.include_with_vars(view_ajax.dataSrc) }},
    {% endif %}
    {% if view_options.individualFiltering %}
        // add request parameters before submit
        "data": function (data) {
            var tableId      = selector,
                tableWrapper = $(tableId + '_wrapper');

            //individual filter
            for (var columnIdx in data.columns) {
                // skip loop if the property is from prototype
                if (!data.columns.hasOwnProperty(columnIdx)) continue;

                // skip loop if column is not searchable anyway
                if (!data.columns[columnIdx].searchable) continue;

                var columnName  = data.columns[columnIdx].name;

                var sourceInput = tableWrapper
                    .find('input[data-filter-column-name="' + columnName +'"]')
                    .first();

                // no column filter found
                if (!sourceInput.length) continue;

                // skip if empty search value
                if (!sourceInput.val()) continue;

                var searchTypeSelect = $('select#' + sourceInput.attr('id').replace('sg-filter', 'sg-search-type'))
                    .first();

                // no filter search type found
                if (!searchTypeSelect.length) continue;

                // add search_type parameter to ajax data obj
                data.columns[columnIdx].search.search_type = searchTypeSelect.val();
            }

            //send column name instead of 1 for ordering
            for (var orderIdx in data.order) {
                // skip loop if the property is from prototype
                if (!data.columns.hasOwnProperty(columnIdx)) continue;

                var columnIdx = data.order[orderIdx].column;

                // skip loop if column is not orderable anyway
                if (!data.columns[columnIdx].orderable) continue;

                data.order[orderIdx].column = data.columns[columnIdx].name;
            }
        }
    {% endif %}
},
